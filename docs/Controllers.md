# Controllers

## Defining Controllers

To define your controllers you should use the next syntax:

```php
class WelcomeController extends \App\Http\Controllers\Controller {
    public function index() { return view('welcome'); }
}
```

Of course, you should register them into the **web.php** or **api.php** as the next way:

```php
Route::get('/', 'WelcomeController@index');
```

You can see that code and the usage of the **class name** and **method name** of your controller.

## Controller Namespacing

Namespacing as all classes on PHP, are the virtual logic folder of your code. 

When you are registering controllers you normally use the next syntax:

```php
Route::get('/', 'Path\WelcomeController@index');
```

Then the **WelcomeController** is located on **App\Http\Controllers\Path**. Usually defined on the head of file:

```php
<?php
namespace App\Http\Controllers\Path;
use App\Http\Controllers\Controller;
class WelcomeController extends Controller {}
```

Well done, you have learned how to use **controller namespacing**.

## Single Action Controller

Also named **invokable controller** are controllers with just one method **__invoke()**. Using the **WelcomeController** example i'll illustrate this in the next way:

```php
<?php
namespace App\Http\Controllers\Path;
use App\Http\Controllers\Controller;
class WelcomeController extends Controller {
    public function __invoke() { return view('welcome'); }
}
```

Then you should register them without the method name, for example:

```php
Route::get('/', 'Path\WelcomeController');
```

Not hard to understand.

## Middleware

Middleware are encapsulated http application layer logic into classes.

There are two different types of middleware: before and after.

This have a syntax like:

```php
<?php

namespace App\Http\Middleware;

use Closure;

class CustomMiddleware
{
    public function handle($request, Closure $next)
    {
        // Before

        $response = $next($request);

        // After

        return $response;
    }
}
```

Obiusly this code can be generated by default using the **artisan** CLI:

```bash
php artisan make:middleware CustomMiddleware
```

### Global middleware

If you need use your middleware into a global context then you should register your class into the **app/Http/Kernel.php** file specifically on **middleware** local property. 

### Per route middleware

When you need to use your logic into specific route you should register your middleware into **routeMiddleware** of **app/Http/Kernel.php** file.

Once register you should use your middleware on route registrarion like this:


```php
Route::get('/', 'Path\WelcomeController')->middleware('custom-middleware');
```

Of course the registration should be done as the following way:

```php
protected $routeMiddleware = [
    ...
    'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
    'custom-middleware' => \App\Http\Middleware\CustomMiddleware::class,
];
```

You can assign the middleware in different ways as **middleware** method is variadic and can receive fully qualified class names.

### Group of middleware

Middleware can be registered and used as groups. Two different groups are registered by default: **web** and **api**. You can look the code available on the **Http Kernel**, specifically on **middlewareGroups** local variable.

### Parameters of middleware

You can pass parameters to middleware as third or more parameters in the middleware class definition like this:

```php
public function handle($request, Closure $next, $role)
{
    if (! $request->user()->hasRole($role)) {
                
    }
    return $next($request);
}
```

Then you should register your using the next syntax:

```php
Route::get('/', 'Path\WelcomeController')->middleware('custom-middleware:parameter');
```

The parameter of variable **role** should be set to **parameter** value.

### Terminate middleware

You can add logic when the request is fully processed. You only should add a new method called **terminate** passing the **request** and the **response** into the middleware class definition.

```php
public function terminate($request, $response)
{
    // Do something magic
}
```

The middleware class will be resolved using **service container** so you can use **singleton** to reduce new instance if you wanna use the same instance for **handle** and **terminate** methods executions.

